"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/useSupabaseData.ts":
/*!**********************************!*\
  !*** ./hooks/useSupabaseData.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSupabaseData: function() { return /* binding */ useSupabaseData; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./lib/supabase.ts\");\n\n\nfunction useSupabaseData(user) {\n    const [songs, setSongs] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [playlists, setPlaylists] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [likedSongs, setLikedSongs] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(new Set());\n    const [lastPlayedSong, setLastPlayedSong] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [currentSongStartTime, setCurrentSongStartTime] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const currentSongRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // Convert database song to UI song format\n    const convertDatabaseSong = function(dbSong) {\n        let isLiked = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        return {\n            file_id: dbSong.file_id,\n            img_id: dbSong.img_id,\n            name: dbSong.name,\n            artist: dbSong.artist,\n            language: dbSong.language,\n            tags: dbSong.tags,\n            views: dbSong.views,\n            likes: dbSong.likes,\n            id: dbSong.file_id.toString(),\n            image: \"https://images.pexels.com/photos/\".concat(dbSong.img_id, \"/pexels-photo-\").concat(dbSong.img_id, \".jpeg?auto=compress&cs=tinysrgb&w=300\"),\n            isLiked\n        };\n    };\n    // Fetch all songs\n    const fetchSongs = async ()=>{\n        try {\n            const { data: songsData, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"songs\").select(\"*\").order(\"views\", {\n                ascending: false\n            });\n            if (error) throw error;\n            let userLikedSongs = new Set();\n            if (user) {\n                const { data: likedData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"liked_songs\").select(\"song_id\").eq(\"user_id\", user.id);\n                if (likedData) {\n                    userLikedSongs = new Set(likedData.map((item)=>item.song_id));\n                    setLikedSongs(userLikedSongs);\n                }\n            }\n            const convertedSongs = (songsData === null || songsData === void 0 ? void 0 : songsData.map((song)=>convertDatabaseSong(song, userLikedSongs.has(song.file_id)))) || [];\n            setSongs(convertedSongs);\n            // Get last played song\n            if (user) {\n                const { data: userData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"users\").select(\"last_song_file_id\").eq(\"id\", user.id).single();\n                if (userData === null || userData === void 0 ? void 0 : userData.last_song_file_id) {\n                    const lastSong = convertedSongs.find((song)=>song.file_id === userData.last_song_file_id);\n                    if (lastSong) {\n                        setLastPlayedSong(lastSong);\n                    }\n                }\n            }\n        } catch (error) {\n            console.error(\"Error fetching songs:\", error);\n        }\n    };\n    // Fetch user playlists\n    const fetchPlaylists = async ()=>{\n        if (!user) {\n            setPlaylists([]);\n            return;\n        }\n        try {\n            const { data: playlistsData, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"playlists\").select(\"\\n          id,\\n          name,\\n          playlist_songs (\\n            songs (*)\\n          )\\n        \").eq(\"user_id\", user.id);\n            if (error) throw error;\n            const convertedPlaylists = (playlistsData === null || playlistsData === void 0 ? void 0 : playlistsData.map((playlist)=>{\n                var _playlist_playlist_songs, _playlistSongs_;\n                const playlistSongs = ((_playlist_playlist_songs = playlist.playlist_songs) === null || _playlist_playlist_songs === void 0 ? void 0 : _playlist_playlist_songs.map((ps)=>convertDatabaseSong(ps.songs, likedSongs.has(ps.songs.file_id)))) || [];\n                return {\n                    id: playlist.id.toString(),\n                    name: playlist.name,\n                    songCount: playlistSongs.length,\n                    image: ((_playlistSongs_ = playlistSongs[0]) === null || _playlistSongs_ === void 0 ? void 0 : _playlistSongs_.image) || \"https://images.pexels.com/photos/1763075/pexels-photo-1763075.jpeg?auto=compress&cs=tinysrgb&w=300\",\n                    songs: playlistSongs\n                };\n            })) || [];\n            setPlaylists(convertedPlaylists);\n        } catch (error) {\n            console.error(\"Error fetching playlists:\", error);\n        }\n    };\n    // Toggle like song\n    const toggleLike = async (songId)=>{\n        if (!user) return;\n        const songFileId = parseInt(songId);\n        const isCurrentlyLiked = likedSongs.has(songFileId);\n        try {\n            if (isCurrentlyLiked) {\n                const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"liked_songs\").delete().eq(\"user_id\", user.id).eq(\"song_id\", songFileId);\n                if (error) throw error;\n                setLikedSongs((prev)=>{\n                    const newSet = new Set(prev);\n                    newSet.delete(songFileId);\n                    return newSet;\n                });\n            } else {\n                const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"liked_songs\").insert({\n                    user_id: user.id,\n                    song_id: songFileId\n                });\n                if (error) throw error;\n                setLikedSongs((prev)=>new Set(prev).add(songFileId));\n            }\n            // Update songs state\n            setSongs((prevSongs)=>prevSongs.map((song)=>song.id === songId ? {\n                        ...song,\n                        isLiked: !isCurrentlyLiked\n                    } : song));\n            // Update playlists state\n            setPlaylists((prevPlaylists)=>prevPlaylists.map((playlist)=>({\n                        ...playlist,\n                        songs: playlist.songs.map((song)=>song.id === songId ? {\n                                ...song,\n                                isLiked: !isCurrentlyLiked\n                            } : song)\n                    })));\n        } catch (error) {\n            console.error(\"Error toggling like:\", error);\n        }\n    };\n    // Create playlist\n    const createPlaylist = async (name)=>{\n        if (!user) return;\n        try {\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"playlists\").insert({\n                user_id: user.id,\n                name\n            }).select().single();\n            if (error) throw error;\n            const newPlaylist = {\n                id: data.id.toString(),\n                name: data.name,\n                songCount: 0,\n                image: \"https://images.pexels.com/photos/1763075/pexels-photo-1763075.jpeg?auto=compress&cs=tinysrgb&w=300\",\n                songs: []\n            };\n            setPlaylists((prev)=>[\n                    ...prev,\n                    newPlaylist\n                ]);\n        } catch (error) {\n            console.error(\"Error creating playlist:\", error);\n        }\n    };\n    // Delete playlist\n    const deletePlaylist = async (playlistId)=>{\n        if (!user) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"playlists\").delete().eq(\"id\", parseInt(playlistId)).eq(\"user_id\", user.id);\n            if (error) throw error;\n            setPlaylists((prev)=>prev.filter((playlist)=>playlist.id !== playlistId));\n        } catch (error) {\n            console.error(\"Error deleting playlist:\", error);\n        }\n    };\n    // Rename playlist\n    const renamePlaylist = async (playlistId, newName)=>{\n        if (!user) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"playlists\").update({\n                name: newName\n            }).eq(\"id\", parseInt(playlistId)).eq(\"user_id\", user.id);\n            if (error) throw error;\n            setPlaylists((prev)=>prev.map((playlist)=>playlist.id === playlistId ? {\n                        ...playlist,\n                        name: newName\n                    } : playlist));\n        } catch (error) {\n            console.error(\"Error renaming playlist:\", error);\n        }\n    };\n    // Add song to playlist\n    const addSongToPlaylist = async (playlistId, song)=>{\n        if (!user) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"playlist_songs\").insert({\n                playlist_id: parseInt(playlistId),\n                song_id: song.file_id\n            });\n            if (error) throw error;\n            setPlaylists((prev)=>prev.map((playlist)=>{\n                    if (playlist.id === playlistId) {\n                        const songExists = playlist.songs.some((s)=>s.id === song.id);\n                        if (!songExists) {\n                            var _updatedSongs_;\n                            const updatedSongs = [\n                                ...playlist.songs,\n                                song\n                            ];\n                            return {\n                                ...playlist,\n                                songs: updatedSongs,\n                                songCount: updatedSongs.length,\n                                image: ((_updatedSongs_ = updatedSongs[0]) === null || _updatedSongs_ === void 0 ? void 0 : _updatedSongs_.image) || playlist.image\n                            };\n                        }\n                    }\n                    return playlist;\n                }));\n        } catch (error) {\n            console.error(\"Error adding song to playlist:\", error);\n        }\n    };\n    // Remove song from playlist\n    const removeSongFromPlaylist = async (playlistId, songId)=>{\n        if (!user) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"playlist_songs\").delete().eq(\"playlist_id\", parseInt(playlistId)).eq(\"song_id\", parseInt(songId));\n            if (error) throw error;\n            setPlaylists((prev)=>prev.map((playlist)=>{\n                    if (playlist.id === playlistId) {\n                        var _updatedSongs_;\n                        const updatedSongs = playlist.songs.filter((song)=>song.id !== songId);\n                        return {\n                            ...playlist,\n                            songs: updatedSongs,\n                            songCount: updatedSongs.length,\n                            image: ((_updatedSongs_ = updatedSongs[0]) === null || _updatedSongs_ === void 0 ? void 0 : _updatedSongs_.image) || \"https://images.pexels.com/photos/1763075/pexels-photo-1763075.jpeg?auto=compress&cs=tinysrgb&w=300\"\n                        };\n                    }\n                    return playlist;\n                }));\n        } catch (error) {\n            console.error(\"Error removing song from playlist:\", error);\n        }\n    };\n    // Update last song in user profile\n    const updateLastSong = async (songId)=>{\n        if (!user) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"users\").update({\n                last_song_file_id: parseInt(songId)\n            }).eq(\"id\", user.id);\n            if (error) throw error;\n        } catch (error) {\n            console.error(\"Error updating last song:\", error);\n        }\n    };\n    // Record listening history with proper time tracking\n    const recordListeningHistory = async (songId)=>{\n        if (!user) return;\n        // If there's a previous song playing, record its listening time\n        if (currentSongRef.current && currentSongStartTime) {\n            const endTime = new Date();\n            const minutesListened = (endTime.getTime() - currentSongStartTime.getTime()) / (1000 * 60);\n            if (minutesListened > 0.1) {\n                try {\n                    const now = new Date();\n                    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"history\").upsert({\n                        user_id: user.id,\n                        song_id: parseInt(currentSongRef.current),\n                        last_date: now.toISOString().split(\"T\")[0],\n                        last_time: now.toTimeString().split(\" \")[0],\n                        minutes_listened: Math.round(minutesListened * 100) / 100 // Round to 2 decimal places\n                    }, {\n                        onConflict: \"user_id,song_id,last_date\",\n                        ignoreDuplicates: false\n                    });\n                    if (error) throw error;\n                } catch (error) {\n                    console.error(\"Error recording previous song history:\", error);\n                }\n            }\n        }\n        // Set new song as current\n        currentSongRef.current = songId;\n        setCurrentSongStartTime(new Date());\n        // Update last song in user profile\n        await updateLastSong(songId);\n    };\n    // Stop current song tracking (when player is closed)\n    const stopCurrentSongTracking = async ()=>{\n        if (currentSongRef.current && currentSongStartTime && user) {\n            const endTime = new Date();\n            const minutesListened = (endTime.getTime() - currentSongStartTime.getTime()) / (1000 * 60);\n            if (minutesListened > 0.1) {\n                try {\n                    const now = new Date();\n                    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"history\").upsert({\n                        user_id: user.id,\n                        song_id: parseInt(currentSongRef.current),\n                        last_date: now.toISOString().split(\"T\")[0],\n                        last_time: now.toTimeString().split(\" \")[0],\n                        minutes_listened: Math.round(minutesListened * 100) / 100\n                    }, {\n                        onConflict: \"user_id,song_id,last_date\",\n                        ignoreDuplicates: false\n                    });\n                    if (error) throw error;\n                } catch (error) {\n                    console.error(\"Error recording final song history:\", error);\n                }\n            }\n        }\n        currentSongRef.current = null;\n        setCurrentSongStartTime(null);\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const loadData = async ()=>{\n            setLoading(true);\n            await Promise.all([\n                fetchSongs(),\n                fetchPlaylists()\n            ]);\n            setLoading(false);\n        };\n        if (user) {\n            loadData();\n        } else {\n            setLoading(false);\n        }\n    }, [\n        user\n    ]);\n    return {\n        songs,\n        playlists,\n        likedSongs: songs.filter((song)=>song.isLiked),\n        lastPlayedSong,\n        loading,\n        toggleLike,\n        createPlaylist,\n        deletePlaylist,\n        renamePlaylist,\n        addSongToPlaylist,\n        removeSongFromPlaylist,\n        recordListeningHistory,\n        stopCurrentSongTracking,\n        refreshData: ()=>{\n            fetchSongs();\n            fetchPlaylists();\n        }\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZVN1cGFiYXNlRGF0YS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQW1EO0FBRXNCO0FBR2xFLFNBQVNJLGdCQUFnQkMsSUFBaUI7SUFDL0MsTUFBTSxDQUFDQyxPQUFPQyxTQUFTLEdBQUdQLCtDQUFRQSxDQUFTLEVBQUU7SUFDN0MsTUFBTSxDQUFDUSxXQUFXQyxhQUFhLEdBQUdULCtDQUFRQSxDQUFhLEVBQUU7SUFDekQsTUFBTSxDQUFDVSxZQUFZQyxjQUFjLEdBQUdYLCtDQUFRQSxDQUFjLElBQUlZO0lBQzlELE1BQU0sQ0FBQ0MsZ0JBQWdCQyxrQkFBa0IsR0FBR2QsK0NBQVFBLENBQWM7SUFDbEUsTUFBTSxDQUFDZSxTQUFTQyxXQUFXLEdBQUdoQiwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNpQixzQkFBc0JDLHdCQUF3QixHQUFHbEIsK0NBQVFBLENBQWM7SUFDOUUsTUFBTW1CLGlCQUFpQmpCLDZDQUFNQSxDQUFnQjtJQUU3QywwQ0FBMEM7SUFDMUMsTUFBTWtCLHNCQUFzQixTQUFDQztZQUFzQkMsMkVBQW1CO2VBQWlCO1lBQ3JGQyxTQUFTRixPQUFPRSxPQUFPO1lBQ3ZCQyxRQUFRSCxPQUFPRyxNQUFNO1lBQ3JCQyxNQUFNSixPQUFPSSxJQUFJO1lBQ2pCQyxRQUFRTCxPQUFPSyxNQUFNO1lBQ3JCQyxVQUFVTixPQUFPTSxRQUFRO1lBQ3pCQyxNQUFNUCxPQUFPTyxJQUFJO1lBQ2pCQyxPQUFPUixPQUFPUSxLQUFLO1lBQ25CQyxPQUFPVCxPQUFPUyxLQUFLO1lBQ25CQyxJQUFJVixPQUFPRSxPQUFPLENBQUNTLFFBQVE7WUFDM0JDLE9BQU8sb0NBQWtFWixPQUE5QkEsT0FBT0csTUFBTSxFQUFDLGtCQUE4QixPQUFkSCxPQUFPRyxNQUFNLEVBQUM7WUFDdkZGO1FBQ0Y7O0lBRUEsa0JBQWtCO0lBQ2xCLE1BQU1ZLGFBQWE7UUFDakIsSUFBSTtZQUNGLE1BQU0sRUFBRUMsTUFBTUMsU0FB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RUFBRTt3QkFDM0NHLGtCQUFrQkMsS0FBS0MsS0FBSyxDQUFDWCxrQkFBa0IsT0FBTztvQkFDeEQsR0FBRzt3QkFDRFksWUFBWTt3QkFDWkMsa0JBQWtCO29CQUNwQjtvQkFFRixJQUFJM0UsT0FBTyxNQUFNQTtnQkFDbkIsRUFBRSxPQUFPQSxPQUFPO29CQUNkbUIsUUFBUW5CLEtBQUssQ0FBQyx1Q0FBdUNBO2dCQUN2RDtZQUNGO1FBQ0Y7UUFFQWxCLGVBQWU2RSxPQUFPLEdBQUc7UUFDekI5RSx3QkFBd0I7SUFDMUI7SUFFQWpCLGdEQUFTQSxDQUFDO1FBQ1IsTUFBTWlILFdBQVc7WUFDZmxHLFdBQVc7WUFDWCxNQUFNbUcsUUFBUUMsR0FBRyxDQUFDO2dCQUFDbEY7Z0JBQWN1QjthQUFpQjtZQUNsRHpDLFdBQVc7UUFDYjtRQUVBLElBQUlYLE1BQU07WUFDUjZHO1FBQ0YsT0FBTztZQUNMbEcsV0FBVztRQUNiO0lBQ0YsR0FBRztRQUFDWDtLQUFLO0lBRVQsT0FBTztRQUNMQztRQUNBRTtRQUNBRSxZQUFZSixNQUFNNkUsTUFBTSxDQUFDbEMsQ0FBQUEsT0FBUUEsS0FBSzNCLE9BQU87UUFDN0NUO1FBQ0FFO1FBQ0FtRDtRQUNBYTtRQUNBRTtRQUNBRztRQUNBRztRQUNBTTtRQUNBRTtRQUNBa0I7UUFDQUksYUFBYTtZQUNYbkY7WUFDQXVCO1FBQ0Y7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2hvb2tzL3VzZVN1cGFiYXNlRGF0YS50cz9hYmZjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgVXNlciB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcydcbmltcG9ydCB7IHN1cGFiYXNlLCBEYXRhYmFzZVNvbmcsIERhdGFiYXNlUGxheWxpc3QgfSBmcm9tICdAL2xpYi9zdXBhYmFzZSdcbmltcG9ydCB7IFNvbmcsIFBsYXlsaXN0IH0gZnJvbSAnQC90eXBlcydcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVN1cGFiYXNlRGF0YSh1c2VyOiBVc2VyIHwgbnVsbCkge1xuICBjb25zdCBbc29uZ3MsIHNldFNvbmdzXSA9IHVzZVN0YXRlPFNvbmdbXT4oW10pXG4gIGNvbnN0IFtwbGF5bGlzdHMsIHNldFBsYXlsaXN0c10gPSB1c2VTdGF0ZTxQbGF5bGlzdFtdPihbXSlcbiAgY29uc3QgW2xpa2VkU29uZ3MsIHNldExpa2VkU29uZ3NdID0gdXNlU3RhdGU8U2V0PG51bWJlcj4+KG5ldyBTZXQoKSlcbiAgY29uc3QgW2xhc3RQbGF5ZWRTb25nLCBzZXRMYXN0UGxheWVkU29uZ10gPSB1c2VTdGF0ZTxTb25nIHwgbnVsbD4obnVsbClcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSlcbiAgY29uc3QgW2N1cnJlbnRTb25nU3RhcnRUaW1lLCBzZXRDdXJyZW50U29uZ1N0YXJ0VGltZV0gPSB1c2VTdGF0ZTxEYXRlIHwgbnVsbD4obnVsbClcbiAgY29uc3QgY3VycmVudFNvbmdSZWYgPSB1c2VSZWY8c3RyaW5nIHwgbnVsbD4obnVsbClcblxuICAvLyBDb252ZXJ0IGRhdGFiYXNlIHNvbmcgdG8gVUkgc29uZyBmb3JtYXRcbiAgY29uc3QgY29udmVydERhdGFiYXNlU29uZyA9IChkYlNvbmc6IERhdGFiYXNlU29uZywgaXNMaWtlZDogYm9vbGVhbiA9IGZhbHNlKTogU29uZyA9PiAoe1xuICAgIGZpbGVfaWQ6IGRiU29uZy5maWxlX2lkLFxuICAgIGltZ19pZDogZGJTb25nLmltZ19pZCxcbiAgICBuYW1lOiBkYlNvbmcubmFtZSxcbiAgICBhcnRpc3Q6IGRiU29uZy5hcnRpc3QsXG4gICAgbGFuZ3VhZ2U6IGRiU29uZy5sYW5ndWFnZSxcbiAgICB0YWdzOiBkYlNvbmcudGFncyxcbiAgICB2aWV3czogZGJTb25nLnZpZXdzLFxuICAgIGxpa2VzOiBkYlNvbmcubGlrZXMsXG4gICAgaWQ6IGRiU29uZy5maWxlX2lkLnRvU3RyaW5nKCksXG4gICAgaW1hZ2U6IGBodHRwczovL2ltYWdlcy5wZXhlbHMuY29tL3Bob3Rvcy8ke2RiU29uZy5pbWdfaWR9L3BleGVscy1waG90by0ke2RiU29uZy5pbWdfaWR9LmpwZWc/YXV0bz1jb21wcmVzcyZjcz10aW55c3JnYiZ3PTMwMGAsXG4gICAgaXNMaWtlZFxuICB9KVxuXG4gIC8vIEZldGNoIGFsbCBzb25nc1xuICBjb25zdCBmZXRjaFNvbmdzID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGE6IHNvbmdzRGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdzb25ncycpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAub3JkZXIoJ3ZpZXdzJywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcblxuICAgICAgbGV0IHVzZXJMaWtlZFNvbmdzID0gbmV3IFNldDxudW1iZXI+KClcbiAgICAgIFxuICAgICAgaWYgKHVzZXIpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhOiBsaWtlZERhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ2xpa2VkX3NvbmdzJylcbiAgICAgICAgICAuc2VsZWN0KCdzb25nX2lkJylcbiAgICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VyLmlkKVxuICAgICAgICBcbiAgICAgICAgaWYgKGxpa2VkRGF0YSkge1xuICAgICAgICAgIHVzZXJMaWtlZFNvbmdzID0gbmV3IFNldChsaWtlZERhdGEubWFwKGl0ZW0gPT4gaXRlbS5zb25nX2lkKSlcbiAgICAgICAgICBzZXRMaWtlZFNvbmdzKHVzZXJMaWtlZFNvbmdzKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbnZlcnRlZFNvbmdzID0gc29uZ3NEYXRhPy5tYXAoc29uZyA9PiBcbiAgICAgICAgY29udmVydERhdGFiYXNlU29uZyhzb25nLCB1c2VyTGlrZWRTb25ncy5oYXMoc29uZy5maWxlX2lkKSlcbiAgICAgICkgfHwgW11cblxuICAgICAgc2V0U29uZ3MoY29udmVydGVkU29uZ3MpXG5cbiAgICAgIC8vIEdldCBsYXN0IHBsYXllZCBzb25nXG4gICAgICBpZiAodXNlcikge1xuICAgICAgICBjb25zdCB7IGRhdGE6IHVzZXJEYXRhIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCd1c2VycycpXG4gICAgICAgICAgLnNlbGVjdCgnbGFzdF9zb25nX2ZpbGVfaWQnKVxuICAgICAgICAgIC5lcSgnaWQnLCB1c2VyLmlkKVxuICAgICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICAgIGlmICh1c2VyRGF0YT8ubGFzdF9zb25nX2ZpbGVfaWQpIHtcbiAgICAgICAgICBjb25zdCBsYXN0U29uZyA9IGNvbnZlcnRlZFNvbmdzLmZpbmQoc29uZyA9PiBzb25nLmZpbGVfaWQgPT09IHVzZXJEYXRhLmxhc3Rfc29uZ19maWxlX2lkKVxuICAgICAgICAgIGlmIChsYXN0U29uZykge1xuICAgICAgICAgICAgc2V0TGFzdFBsYXllZFNvbmcobGFzdFNvbmcpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHNvbmdzOicsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8vIEZldGNoIHVzZXIgcGxheWxpc3RzXG4gIGNvbnN0IGZldGNoUGxheWxpc3RzID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghdXNlcikge1xuICAgICAgc2V0UGxheWxpc3RzKFtdKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YTogcGxheWxpc3RzRGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwbGF5bGlzdHMnKVxuICAgICAgICAuc2VsZWN0KGBcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHBsYXlsaXN0X3NvbmdzIChcbiAgICAgICAgICAgIHNvbmdzICgqKVxuICAgICAgICAgIClcbiAgICAgICAgYClcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci5pZClcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuXG4gICAgICBjb25zdCBjb252ZXJ0ZWRQbGF5bGlzdHM6IFBsYXlsaXN0W10gPSBwbGF5bGlzdHNEYXRhPy5tYXAocGxheWxpc3QgPT4ge1xuICAgICAgICBjb25zdCBwbGF5bGlzdFNvbmdzID0gcGxheWxpc3QucGxheWxpc3Rfc29uZ3M/Lm1hcCgocHM6IGFueSkgPT4gXG4gICAgICAgICAgY29udmVydERhdGFiYXNlU29uZyhwcy5zb25ncywgbGlrZWRTb25ncy5oYXMocHMuc29uZ3MuZmlsZV9pZCkpXG4gICAgICAgICkgfHwgW11cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkOiBwbGF5bGlzdC5pZC50b1N0cmluZygpLFxuICAgICAgICAgIG5hbWU6IHBsYXlsaXN0Lm5hbWUsXG4gICAgICAgICAgc29uZ0NvdW50OiBwbGF5bGlzdFNvbmdzLmxlbmd0aCxcbiAgICAgICAgICBpbWFnZTogcGxheWxpc3RTb25nc1swXT8uaW1hZ2UgfHwgJ2h0dHBzOi8vaW1hZ2VzLnBleGVscy5jb20vcGhvdG9zLzE3NjMwNzUvcGV4ZWxzLXBob3RvLTE3NjMwNzUuanBlZz9hdXRvPWNvbXByZXNzJmNzPXRpbnlzcmdiJnc9MzAwJyxcbiAgICAgICAgICBzb25nczogcGxheWxpc3RTb25nc1xuICAgICAgICB9XG4gICAgICB9KSB8fCBbXVxuXG4gICAgICBzZXRQbGF5bGlzdHMoY29udmVydGVkUGxheWxpc3RzKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwbGF5bGlzdHM6JywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gVG9nZ2xlIGxpa2Ugc29uZ1xuICBjb25zdCB0b2dnbGVMaWtlID0gYXN5bmMgKHNvbmdJZDogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCF1c2VyKSByZXR1cm5cblxuICAgIGNvbnN0IHNvbmdGaWxlSWQgPSBwYXJzZUludChzb25nSWQpXG4gICAgY29uc3QgaXNDdXJyZW50bHlMaWtlZCA9IGxpa2VkU29uZ3MuaGFzKHNvbmdGaWxlSWQpXG5cbiAgICB0cnkge1xuICAgICAgaWYgKGlzQ3VycmVudGx5TGlrZWQpIHtcbiAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgnbGlrZWRfc29uZ3MnKVxuICAgICAgICAgIC5kZWxldGUoKVxuICAgICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXIuaWQpXG4gICAgICAgICAgLmVxKCdzb25nX2lkJywgc29uZ0ZpbGVJZClcblxuICAgICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgICAgc2V0TGlrZWRTb25ncyhwcmV2ID0+IHtcbiAgICAgICAgICBjb25zdCBuZXdTZXQgPSBuZXcgU2V0KHByZXYpXG4gICAgICAgICAgbmV3U2V0LmRlbGV0ZShzb25nRmlsZUlkKVxuICAgICAgICAgIHJldHVybiBuZXdTZXRcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ2xpa2VkX3NvbmdzJylcbiAgICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICAgIHVzZXJfaWQ6IHVzZXIuaWQsXG4gICAgICAgICAgICBzb25nX2lkOiBzb25nRmlsZUlkXG4gICAgICAgICAgfSlcblxuICAgICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgICAgc2V0TGlrZWRTb25ncyhwcmV2ID0+IG5ldyBTZXQocHJldikuYWRkKHNvbmdGaWxlSWQpKVxuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgc29uZ3Mgc3RhdGVcbiAgICAgIHNldFNvbmdzKHByZXZTb25ncyA9PiBcbiAgICAgICAgcHJldlNvbmdzLm1hcChzb25nID0+IFxuICAgICAgICAgIHNvbmcuaWQgPT09IHNvbmdJZCA/IHsgLi4uc29uZywgaXNMaWtlZDogIWlzQ3VycmVudGx5TGlrZWQgfSA6IHNvbmdcbiAgICAgICAgKVxuICAgICAgKVxuXG4gICAgICAvLyBVcGRhdGUgcGxheWxpc3RzIHN0YXRlXG4gICAgICBzZXRQbGF5bGlzdHMocHJldlBsYXlsaXN0cyA9PlxuICAgICAgICBwcmV2UGxheWxpc3RzLm1hcChwbGF5bGlzdCA9PiAoe1xuICAgICAgICAgIC4uLnBsYXlsaXN0LFxuICAgICAgICAgIHNvbmdzOiBwbGF5bGlzdC5zb25ncy5tYXAoc29uZyA9PlxuICAgICAgICAgICAgc29uZy5pZCA9PT0gc29uZ0lkID8geyAuLi5zb25nLCBpc0xpa2VkOiAhaXNDdXJyZW50bHlMaWtlZCB9IDogc29uZ1xuICAgICAgICAgIClcbiAgICAgICAgfSkpXG4gICAgICApXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHRvZ2dsaW5nIGxpa2U6JywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gQ3JlYXRlIHBsYXlsaXN0XG4gIGNvbnN0IGNyZWF0ZVBsYXlsaXN0ID0gYXN5bmMgKG5hbWU6IHN0cmluZykgPT4ge1xuICAgIGlmICghdXNlcikgcmV0dXJuXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3BsYXlsaXN0cycpXG4gICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgIHVzZXJfaWQ6IHVzZXIuaWQsXG4gICAgICAgICAgbmFtZVxuICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgLnNpbmdsZSgpXG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcblxuICAgICAgY29uc3QgbmV3UGxheWxpc3Q6IFBsYXlsaXN0ID0ge1xuICAgICAgICBpZDogZGF0YS5pZC50b1N0cmluZygpLFxuICAgICAgICBuYW1lOiBkYXRhLm5hbWUsXG4gICAgICAgIHNvbmdDb3VudDogMCxcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL2ltYWdlcy5wZXhlbHMuY29tL3Bob3Rvcy8xNzYzMDc1L3BleGVscy1waG90by0xNzYzMDc1LmpwZWc/YXV0bz1jb21wcmVzcyZjcz10aW55c3JnYiZ3PTMwMCcsXG4gICAgICAgIHNvbmdzOiBbXVxuICAgICAgfVxuXG4gICAgICBzZXRQbGF5bGlzdHMocHJldiA9PiBbLi4ucHJldiwgbmV3UGxheWxpc3RdKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBwbGF5bGlzdDonLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICAvLyBEZWxldGUgcGxheWxpc3RcbiAgY29uc3QgZGVsZXRlUGxheWxpc3QgPSBhc3luYyAocGxheWxpc3RJZDogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCF1c2VyKSByZXR1cm5cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncGxheWxpc3RzJylcbiAgICAgICAgLmRlbGV0ZSgpXG4gICAgICAgIC5lcSgnaWQnLCBwYXJzZUludChwbGF5bGlzdElkKSlcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci5pZClcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuXG4gICAgICBzZXRQbGF5bGlzdHMocHJldiA9PiBwcmV2LmZpbHRlcihwbGF5bGlzdCA9PiBwbGF5bGlzdC5pZCAhPT0gcGxheWxpc3RJZCkpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIHBsYXlsaXN0OicsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlbmFtZSBwbGF5bGlzdFxuICBjb25zdCByZW5hbWVQbGF5bGlzdCA9IGFzeW5jIChwbGF5bGlzdElkOiBzdHJpbmcsIG5ld05hbWU6IHN0cmluZykgPT4ge1xuICAgIGlmICghdXNlcikgcmV0dXJuXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3BsYXlsaXN0cycpXG4gICAgICAgIC51cGRhdGUoeyBuYW1lOiBuZXdOYW1lIH0pXG4gICAgICAgIC5lcSgnaWQnLCBwYXJzZUludChwbGF5bGlzdElkKSlcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci5pZClcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuXG4gICAgICBzZXRQbGF5bGlzdHMocHJldiA9PiBcbiAgICAgICAgcHJldi5tYXAocGxheWxpc3QgPT4gXG4gICAgICAgICAgcGxheWxpc3QuaWQgPT09IHBsYXlsaXN0SWQgXG4gICAgICAgICAgICA/IHsgLi4ucGxheWxpc3QsIG5hbWU6IG5ld05hbWUgfVxuICAgICAgICAgICAgOiBwbGF5bGlzdFxuICAgICAgICApXG4gICAgICApXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbmFtaW5nIHBsYXlsaXN0OicsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBzb25nIHRvIHBsYXlsaXN0XG4gIGNvbnN0IGFkZFNvbmdUb1BsYXlsaXN0ID0gYXN5bmMgKHBsYXlsaXN0SWQ6IHN0cmluZywgc29uZzogU29uZykgPT4ge1xuICAgIGlmICghdXNlcikgcmV0dXJuXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3BsYXlsaXN0X3NvbmdzJylcbiAgICAgICAgLmluc2VydCh7XG4gICAgICAgICAgcGxheWxpc3RfaWQ6IHBhcnNlSW50KHBsYXlsaXN0SWQpLFxuICAgICAgICAgIHNvbmdfaWQ6IHNvbmcuZmlsZV9pZFxuICAgICAgICB9KVxuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgIHNldFBsYXlsaXN0cyhwcmV2ID0+IFxuICAgICAgICBwcmV2Lm1hcChwbGF5bGlzdCA9PiB7XG4gICAgICAgICAgaWYgKHBsYXlsaXN0LmlkID09PSBwbGF5bGlzdElkKSB7XG4gICAgICAgICAgICBjb25zdCBzb25nRXhpc3RzID0gcGxheWxpc3Quc29uZ3Muc29tZShzID0+IHMuaWQgPT09IHNvbmcuaWQpXG4gICAgICAgICAgICBpZiAoIXNvbmdFeGlzdHMpIHtcbiAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZFNvbmdzID0gWy4uLnBsYXlsaXN0LnNvbmdzLCBzb25nXVxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLnBsYXlsaXN0LFxuICAgICAgICAgICAgICAgIHNvbmdzOiB1cGRhdGVkU29uZ3MsXG4gICAgICAgICAgICAgICAgc29uZ0NvdW50OiB1cGRhdGVkU29uZ3MubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGltYWdlOiB1cGRhdGVkU29uZ3NbMF0/LmltYWdlIHx8IHBsYXlsaXN0LmltYWdlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHBsYXlsaXN0XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBzb25nIHRvIHBsYXlsaXN0OicsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlbW92ZSBzb25nIGZyb20gcGxheWxpc3RcbiAgY29uc3QgcmVtb3ZlU29uZ0Zyb21QbGF5bGlzdCA9IGFzeW5jIChwbGF5bGlzdElkOiBzdHJpbmcsIHNvbmdJZDogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCF1c2VyKSByZXR1cm5cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncGxheWxpc3Rfc29uZ3MnKVxuICAgICAgICAuZGVsZXRlKClcbiAgICAgICAgLmVxKCdwbGF5bGlzdF9pZCcsIHBhcnNlSW50KHBsYXlsaXN0SWQpKVxuICAgICAgICAuZXEoJ3NvbmdfaWQnLCBwYXJzZUludChzb25nSWQpKVxuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgIHNldFBsYXlsaXN0cyhwcmV2ID0+IFxuICAgICAgICBwcmV2Lm1hcChwbGF5bGlzdCA9PiB7XG4gICAgICAgICAgaWYgKHBsYXlsaXN0LmlkID09PSBwbGF5bGlzdElkKSB7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkU29uZ3MgPSBwbGF5bGlzdC5zb25ncy5maWx0ZXIoc29uZyA9PiBzb25nLmlkICE9PSBzb25nSWQpXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi5wbGF5bGlzdCxcbiAgICAgICAgICAgICAgc29uZ3M6IHVwZGF0ZWRTb25ncyxcbiAgICAgICAgICAgICAgc29uZ0NvdW50OiB1cGRhdGVkU29uZ3MubGVuZ3RoLFxuICAgICAgICAgICAgICBpbWFnZTogdXBkYXRlZFNvbmdzWzBdPy5pbWFnZSB8fCAnaHR0cHM6Ly9pbWFnZXMucGV4ZWxzLmNvbS9waG90b3MvMTc2MzA3NS9wZXhlbHMtcGhvdG8tMTc2MzA3NS5qcGVnP2F1dG89Y29tcHJlc3MmY3M9dGlueXNyZ2Imdz0zMDAnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwbGF5bGlzdFxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW1vdmluZyBzb25nIGZyb20gcGxheWxpc3Q6JywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gVXBkYXRlIGxhc3Qgc29uZyBpbiB1c2VyIHByb2ZpbGVcbiAgY29uc3QgdXBkYXRlTGFzdFNvbmcgPSBhc3luYyAoc29uZ0lkOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIXVzZXIpIHJldHVyblxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd1c2VycycpXG4gICAgICAgIC51cGRhdGUoeyBsYXN0X3NvbmdfZmlsZV9pZDogcGFyc2VJbnQoc29uZ0lkKSB9KVxuICAgICAgICAuZXEoJ2lkJywgdXNlci5pZClcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBsYXN0IHNvbmc6JywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gUmVjb3JkIGxpc3RlbmluZyBoaXN0b3J5IHdpdGggcHJvcGVyIHRpbWUgdHJhY2tpbmdcbiAgY29uc3QgcmVjb3JkTGlzdGVuaW5nSGlzdG9yeSA9IGFzeW5jIChzb25nSWQ6IHN0cmluZykgPT4ge1xuICAgIGlmICghdXNlcikgcmV0dXJuXG5cbiAgICAvLyBJZiB0aGVyZSdzIGEgcHJldmlvdXMgc29uZyBwbGF5aW5nLCByZWNvcmQgaXRzIGxpc3RlbmluZyB0aW1lXG4gICAgaWYgKGN1cnJlbnRTb25nUmVmLmN1cnJlbnQgJiYgY3VycmVudFNvbmdTdGFydFRpbWUpIHtcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBuZXcgRGF0ZSgpXG4gICAgICBjb25zdCBtaW51dGVzTGlzdGVuZWQgPSAoZW5kVGltZS5nZXRUaW1lKCkgLSBjdXJyZW50U29uZ1N0YXJ0VGltZS5nZXRUaW1lKCkpIC8gKDEwMDAgKiA2MClcbiAgICAgIFxuICAgICAgaWYgKG1pbnV0ZXNMaXN0ZW5lZCA+IDAuMSkgeyAvLyBPbmx5IHJlY29yZCBpZiBsaXN0ZW5lZCBmb3IgbW9yZSB0aGFuIDYgc2Vjb25kc1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKClcbiAgICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgLmZyb20oJ2hpc3RvcnknKVxuICAgICAgICAgICAgLnVwc2VydCh7XG4gICAgICAgICAgICAgIHVzZXJfaWQ6IHVzZXIuaWQsXG4gICAgICAgICAgICAgIHNvbmdfaWQ6IHBhcnNlSW50KGN1cnJlbnRTb25nUmVmLmN1cnJlbnQpLFxuICAgICAgICAgICAgICBsYXN0X2RhdGU6IG5vdy50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0sXG4gICAgICAgICAgICAgIGxhc3RfdGltZTogbm93LnRvVGltZVN0cmluZygpLnNwbGl0KCcgJylbMF0sXG4gICAgICAgICAgICAgIG1pbnV0ZXNfbGlzdGVuZWQ6IE1hdGgucm91bmQobWludXRlc0xpc3RlbmVkICogMTAwKSAvIDEwMCAvLyBSb3VuZCB0byAyIGRlY2ltYWwgcGxhY2VzXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIG9uQ29uZmxpY3Q6ICd1c2VyX2lkLHNvbmdfaWQsbGFzdF9kYXRlJyxcbiAgICAgICAgICAgICAgaWdub3JlRHVwbGljYXRlczogZmFsc2VcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVjb3JkaW5nIHByZXZpb3VzIHNvbmcgaGlzdG9yeTonLCBlcnJvcilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldCBuZXcgc29uZyBhcyBjdXJyZW50XG4gICAgY3VycmVudFNvbmdSZWYuY3VycmVudCA9IHNvbmdJZFxuICAgIHNldEN1cnJlbnRTb25nU3RhcnRUaW1lKG5ldyBEYXRlKCkpXG4gICAgXG4gICAgLy8gVXBkYXRlIGxhc3Qgc29uZyBpbiB1c2VyIHByb2ZpbGVcbiAgICBhd2FpdCB1cGRhdGVMYXN0U29uZyhzb25nSWQpXG4gIH1cblxuICAvLyBTdG9wIGN1cnJlbnQgc29uZyB0cmFja2luZyAod2hlbiBwbGF5ZXIgaXMgY2xvc2VkKVxuICBjb25zdCBzdG9wQ3VycmVudFNvbmdUcmFja2luZyA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoY3VycmVudFNvbmdSZWYuY3VycmVudCAmJiBjdXJyZW50U29uZ1N0YXJ0VGltZSAmJiB1c2VyKSB7XG4gICAgICBjb25zdCBlbmRUaW1lID0gbmV3IERhdGUoKVxuICAgICAgY29uc3QgbWludXRlc0xpc3RlbmVkID0gKGVuZFRpbWUuZ2V0VGltZSgpIC0gY3VycmVudFNvbmdTdGFydFRpbWUuZ2V0VGltZSgpKSAvICgxMDAwICogNjApXG4gICAgICBcbiAgICAgIGlmIChtaW51dGVzTGlzdGVuZWQgPiAwLjEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpXG4gICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgIC5mcm9tKCdoaXN0b3J5JylcbiAgICAgICAgICAgIC51cHNlcnQoe1xuICAgICAgICAgICAgICB1c2VyX2lkOiB1c2VyLmlkLFxuICAgICAgICAgICAgICBzb25nX2lkOiBwYXJzZUludChjdXJyZW50U29uZ1JlZi5jdXJyZW50KSxcbiAgICAgICAgICAgICAgbGFzdF9kYXRlOiBub3cudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdLFxuICAgICAgICAgICAgICBsYXN0X3RpbWU6IG5vdy50b1RpbWVTdHJpbmcoKS5zcGxpdCgnICcpWzBdLFxuICAgICAgICAgICAgICBtaW51dGVzX2xpc3RlbmVkOiBNYXRoLnJvdW5kKG1pbnV0ZXNMaXN0ZW5lZCAqIDEwMCkgLyAxMDBcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgb25Db25mbGljdDogJ3VzZXJfaWQsc29uZ19pZCxsYXN0X2RhdGUnLFxuICAgICAgICAgICAgICBpZ25vcmVEdXBsaWNhdGVzOiBmYWxzZVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZWNvcmRpbmcgZmluYWwgc29uZyBoaXN0b3J5OicsIGVycm9yKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3VycmVudFNvbmdSZWYuY3VycmVudCA9IG51bGxcbiAgICBzZXRDdXJyZW50U29uZ1N0YXJ0VGltZShudWxsKVxuICB9XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBsb2FkRGF0YSA9IGFzeW5jICgpID0+IHtcbiAgICAgIHNldExvYWRpbmcodHJ1ZSlcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtmZXRjaFNvbmdzKCksIGZldGNoUGxheWxpc3RzKCldKVxuICAgICAgc2V0TG9hZGluZyhmYWxzZSlcbiAgICB9XG5cbiAgICBpZiAodXNlcikge1xuICAgICAgbG9hZERhdGEoKVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKVxuICAgIH1cbiAgfSwgW3VzZXJdKVxuXG4gIHJldHVybiB7XG4gICAgc29uZ3MsXG4gICAgcGxheWxpc3RzLFxuICAgIGxpa2VkU29uZ3M6IHNvbmdzLmZpbHRlcihzb25nID0+IHNvbmcuaXNMaWtlZCksXG4gICAgbGFzdFBsYXllZFNvbmcsXG4gICAgbG9hZGluZyxcbiAgICB0b2dnbGVMaWtlLFxuICAgIGNyZWF0ZVBsYXlsaXN0LFxuICAgIGRlbGV0ZVBsYXlsaXN0LFxuICAgIHJlbmFtZVBsYXlsaXN0LFxuICAgIGFkZFNvbmdUb1BsYXlsaXN0LFxuICAgIHJlbW92ZVNvbmdGcm9tUGxheWxpc3QsXG4gICAgcmVjb3JkTGlzdGVuaW5nSGlzdG9yeSxcbiAgICBzdG9wQ3VycmVudFNvbmdUcmFja2luZyxcbiAgICByZWZyZXNoRGF0YTogKCkgPT4ge1xuICAgICAgZmV0Y2hTb25ncygpXG4gICAgICBmZXRjaFBsYXlsaXN0cygpXG4gICAgfVxuICB9XG59Il0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlUmVmIiwic3VwYWJhc2UiLCJ1c2VTdXBhYmFzZURhdGEiLCJ1c2VyIiwic29uZ3MiLCJzZXRTb25ncyIsInBsYXlsaXN0cyIsInNldFBsYXlsaXN0cyIsImxpa2VkU29uZ3MiLCJzZXRMaWtlZFNvbmdzIiwiU2V0IiwibGFzdFBsYXllZFNvbmciLCJzZXRMYXN0UGxheWVkU29uZyIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiY3VycmVudFNvbmdTdGFydFRpbWUiLCJzZXRDdXJyZW50U29uZ1N0YXJ0VGltZSIsImN1cnJlbnRTb25nUmVmIiwiY29udmVydERhdGFiYXNlU29uZyIsImRiU29uZyIsImlzTGlrZWQiLCJmaWxlX2lkIiwiaW1nX2lkIiwibmFtZSIsImFydGlzdCIsImxhbmd1YWdlIiwidGFncyIsInZpZXdzIiwibGlrZXMiLCJpZCIsInRvU3RyaW5nIiwiaW1hZ2UiLCJmZXRjaFNvbmdzIiwiZGF0YSIsInNvbmdzRGF0YSIsImVycm9yIiwiZnJvbSIsInNlbGVjdCIsIm9yZGVyIiwiYXNjZW5kaW5nIiwidXNlckxpa2VkU29uZ3MiLCJsaWtlZERhdGEiLCJlcSIsIm1hcCIsIml0ZW0iLCJzb25nX2lkIiwiY29udmVydGVkU29uZ3MiLCJzb25nIiwiaGFzIiwidXNlckRhdGEiLCJzaW5nbGUiLCJsYXN0X3NvbmdfZmlsZV9pZCIsImxhc3RTb25nIiwiZmluZCIsImNvbnNvbGUiLCJmZXRjaFBsYXlsaXN0cyIsInBsYXlsaXN0c0RhdGEiLCJjb252ZXJ0ZWRQbGF5bGlzdHMiLCJwbGF5bGlzdCIsInBsYXlsaXN0U29uZ3MiLCJwbGF5bGlzdF9zb25ncyIsInBzIiwic29uZ0NvdW50IiwibGVuZ3RoIiwidG9nZ2xlTGlrZSIsInNvbmdJZCIsInNvbmdGaWxlSWQiLCJwYXJzZUludCIsImlzQ3VycmVudGx5TGlrZWQiLCJkZWxldGUiLCJwcmV2IiwibmV3U2V0IiwiaW5zZXJ0IiwidXNlcl9pZCIsImFkZCIsInByZXZTb25ncyIsInByZXZQbGF5bGlzdHMiLCJjcmVhdGVQbGF5bGlzdCIsIm5ld1BsYXlsaXN0IiwiZGVsZXRlUGxheWxpc3QiLCJwbGF5bGlzdElkIiwiZmlsdGVyIiwicmVuYW1lUGxheWxpc3QiLCJuZXdOYW1lIiwidXBkYXRlIiwiYWRkU29uZ1RvUGxheWxpc3QiLCJwbGF5bGlzdF9pZCIsInNvbmdFeGlzdHMiLCJzb21lIiwicyIsInVwZGF0ZWRTb25ncyIsInJlbW92ZVNvbmdGcm9tUGxheWxpc3QiLCJ1cGRhdGVMYXN0U29uZyIsInJlY29yZExpc3RlbmluZ0hpc3RvcnkiLCJjdXJyZW50IiwiZW5kVGltZSIsIkRhdGUiLCJtaW51dGVzTGlzdGVuZWQiLCJnZXRUaW1lIiwibm93IiwidXBzZXJ0IiwibGFzdF9kYXRlIiwidG9JU09TdHJpbmciLCJzcGxpdCIsImxhc3RfdGltZSIsInRvVGltZVN0cmluZyIsIm1pbnV0ZXNfbGlzdGVuZWQiLCJNYXRoIiwicm91bmQiLCJvbkNvbmZsaWN0IiwiaWdub3JlRHVwbGljYXRlcyIsInN0b3BDdXJyZW50U29uZ1RyYWNraW5nIiwibG9hZERhdGEiLCJQcm9taXNlIiwiYWxsIiwicmVmcmVzaERhdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useSupabaseData.ts\n"));

/***/ })

});